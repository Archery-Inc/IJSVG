//
//  IJSVGExporter.m
//  IJSVGExample
//
//  Created by Curtis Hard on 06/01/2017.
//  Copyright Â© 2017 Curtis Hard. All rights reserved.
//

#import <IJSVG/IJSVG.h>
#import <IJSVG/IJSVGExporter.h>
#import <IJSVG/IJSVGExporterPathInstruction.h>
#import <IJSVG/IJSVGGradientLayer.h>
#import <IJSVG/IJSVGGroupLayer.h>
#import <IJSVG/IJSVGImageLayer.h>
#import <IJSVG/IJSVGLinearGradient.h>
#import <IJSVG/IJSVGMath.h>
#import <IJSVG/IJSVGPatternLayer.h>
#import <IJSVG/IJSVGRadialGradient.h>
#import <IJSVG/IJSVGShapeLayer.h>
#import <IJSVG/IJSVGStrokeLayer.h>
#import <IJSVG/IJSVGFilterLayer.h>
#import <IJSVG/IJSVGTransformLayer.h>
#import <IJSVG/IJSVGParser.h>

@implementation IJSVGExporter

#define XML_DOC_VERSION 1.1f
#define XML_DOC_NS @"http://www.w3.org/2000/svg"
#define XML_DOC_NSXLINK @"http://www.w3.org/1999/xlink"
#define XML_DOCTYPE_VERSION @"1.0"
#define XML_DOC_CHARSET @"UTF-8"
#define XML_DOC_GENERATOR @"Generated by IJSVG (https://github.com/iconjar/IJSVG)"

BOOL IJSVGExporterHasOption(IJSVGExporterOptions options, NSInteger option)
{
    return (options & option) != 0;
};

const NSArray<NSString*>* IJSVGShortCharacterArray(void)
{
    static NSArray* _array;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _array = @[ @"a", @"b", @"c", @"d", @"e", @"f", @"g", @"h", @"i", @"j", @"k", @"l",
            @"m", @"n", @"o", @"p", @"q", @"r", @"s", @"t", @"u", @"v", @"w", @"x", @"y", @"z",
            @"A", @"B", @"C", @"D", @"E", @"F", @"G", @"H", @"I", @"J", @"K", @"L",
            @"M", @"N", @"O", @"P", @"Q", @"R", @"S", @"T", @"U", @"V", @"W", @"X", @"Y", @"Z" ];
    });
    return _array;
}

const NSDictionary<NSString*, NSString*>* IJSVGDefaultAttributes(void)
{
    static NSDictionary* _defaults;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _defaults = @{
            @"clip": @"auto",
            @"clip-path": @"none",
            @"clip-rule": @"nonzero",
            @"mask": @"none",
            @"opacity": @"1",
            @"stop-color": @"#000",
            @"stop-opacity": @"1",
            @"fill-opacity": @"1",
            @"fill-rule": @"nonzero",
            @"fill": @"#000",
            @"stroke": @"none",
            @"stroke-width": @"1",
            @"stroke-linecap": @"butt",
            @"stroke-linejoin": @"miter",
            @"stroke-miterlimit": @"4",
            @"stroke-dasharray": @"none",
            @"stroke-dashoffset": @"0",
            @"stroke-opacity": @"1",
            @"paint-order": @"normal",
            @"vector-effect": @"none",
            @"display": @"inline",
            @"visibility": @"visible",
            @"marker-start": @"none",
            @"marker-mid": @"none",
            @"marker-end": @"none",
            @"color-interpolation": @"sRGB",
            @"color-interpolation-filters": @"linearRGB",
            @"color-rendering": @"auto",
            @"shape-rendering": @"auto",
            @"text-rendering": @"auto",
            @"image-rendering": @"auto",
            @"font-style": @"normal",
            @"font-variant": @"normal",
            @"font-weight": @"normal",
            @"font-stretch": @"normal",
            @"font-size": @"medium",
            @"font-size-adjust": @"none",
            @"kerning": @"auto",
            @"letter-spacing": @"normal",
            @"word-spacing": @"normal",
            @"text-decoration": @"none",
            @"text-anchor": @"start",
            @"text-overflow": @"clip",
            @"writing-mode": @"lr-tb",
            @"glyph-orientation-vertical": @"auto",
            @"glyph-orientation-horizontal": @"0deg",
            @"direction": @"ltr",
            @"unicode-bidi": @"normal",
            @"dominant-baseline": @"auto",
            @"alignment-baseline": @"baseline",
            @"baseline-shift": @"baseline"
        };
    });
    return _defaults;
}

const NSArray* IJSVGInheritableAttributes(void)
{
    static NSArray* _attributes;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _attributes = @[
            @"clip-rule",
            @"color",
            @"color-interpolation",
            @"color-interpolation-filters",
            @"color-profile",
            @"color-rendering",
            @"cursor",
            @"direction",
            @"fill",
            @"fill-opacity",
            @"fill-rule",
            @"font",
            @"font-family",
            @"font-size",
            @"font-size-adjust",
            @"font-stretch",
            @"font-style",
            @"font-variant",
            @"font-weight",
            @"glyph-orientation-horizontal",
            @"glyph-orientation-vertical",
            @"image-rendering",
            @"kerning",
            @"letter-spacing",
            @"marker",
            @"marker-end",
            @"marker-mid",
            @"marker-start",
            @"pointer-events",
            @"shape-rendering",
            @"stroke",
            @"stroke-dasharray",
            @"stroke-dashoffset",
            @"stroke-linecap",
            @"stroke-linejoin",
            @"stroke-miterlimit",
            @"stroke-opacity",
            @"stroke-width",
            @"text-anchor",
            @"text-rendering",
            @"visibility",
            @"white-space",
            @"word-spacing",
            @"writing-mode"
        ];
    });
    return _attributes;
}

void IJSVGApplyAttributesToElement(NSDictionary* _Nonnull attributes, NSXMLElement* element)
{
    [element setAttributesAsDictionary:attributes];
};

NSDictionary<NSString*, NSString*>* IJSVGElementAttributeDictionary(NSXMLElement* element)
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    for (NSXMLNode* attribute in element.attributes) {
        dict[attribute.name] = attribute.stringValue;
    }
    return dict;
};

NSString* IJSVGHashURL(NSString* key)
{
    return [NSString stringWithFormat:@"url(#%@)", key];
};

NSString* IJSVGHash(NSString* key)
{
    return [@"#" stringByAppendingString:key];
}

- (id)initWithSVG:(IJSVG*)svg
             size:(CGSize)size
          options:(IJSVGExporterOptions)options
{
    IJSVGFloatingPointOptions fpo = IJSVGFloatingPointOptionsDefault();
    return [self initWithSVG:svg
                        size:size
                     options:options
        floatingPointOptions:fpo];
}

- (id)initWithSVG:(IJSVG*)svg
             size:(CGSize)size
          options:(IJSVGExporterOptions)options
    floatingPointOptions:(IJSVGFloatingPointOptions)floatingPointOptions
{
    if ((self = [super init]) != nil) {
        _options = options;
        _size = size;
        _svg = svg;

        // defaults for floating point rounding, if any
        _floatingPointOptions = floatingPointOptions;
    }
    return self;
}

- (void)setDelegate:(id<IJSVGExporterDelegate>)delegate
{
    _delegate = delegate;
    _respondsTo.identifierForElement = [delegate respondsToSelector:@selector(svgExporter:identifierForElement:type:defaultID:)];
    _respondsTo.stringForColor = [delegate respondsToSelector:@selector(svgExporter:stringForColor:flags:options:)];
}

- (NSXMLElement*)defElement
{
    if (_defElement != nil) {
        return _defElement;
    }
    return _defElement = [[NSXMLElement alloc] initWithName:@"defs"];
}

- (NSString*)viewBoxWithRect:(NSRect)rect
{
    char* buffer;
    asprintf(&buffer, "%g %g %g %g", rect.origin.x, rect.origin.y,
        rect.size.width, rect.size.height);
    NSString* viewBox = [NSString stringWithCString:buffer
                                           encoding:NSUTF8StringEncoding];
    free(buffer);
    return viewBox;
}

- (NSString*)viewBoxAlignment:(IJSVGViewBoxAlignment)alignment
                  meetOrSlice:(IJSVGViewBoxMeetOrSlice)meetOrSlice
{
    NSString* str = nil;
    switch(alignment) {
        default:
        case IJSVGViewBoxAlignmentUnknown: {
            return nil;
        }
        case IJSVGViewBoxAlignmentNone: {
            return @"none";
        }
        case IJSVGViewBoxAlignmentXMinYMin: {
            str = @"xMinYMin";
            break;
        }
        case IJSVGViewBoxAlignmentXMidYMin: {
            str = @"xMidYMin";
            break;
        }
        case IJSVGViewBoxAlignmentXMaxYMin: {
            str = @"xMaxYMin";
            break;
        }
        case IJSVGViewBoxAlignmentXMinYMid: {
            str = @"xMinYMid";
            break;
        }
        case IJSVGViewBoxAlignmentXMidYMid: {
            str = @"xMidYMid";
            break;
        }
        case IJSVGViewBoxAlignmentXMaxYMid: {
            str = @"xMaxYMid";
            break;
        }
        case IJSVGViewBoxAlignmentXMinYMax: {
            str = @"xMinYMax";
            break;
        }
        case IJSVGViewBoxAlignmentXMidYMax: {
            str = @"xMidYMax";
            break;
        }
        case IJSVGViewBoxAlignmentXMaxYMax: {
            str = @"xMaxYMax";
            break;
        }
    }
    if(meetOrSlice == IJSVGViewBoxMeetOrSliceMeet) {
        return str;
    }
    return [str stringByAppendingString:@" slice"];
}

- (NSXMLElement*)rootNode:(NSXMLElement**)nestedRoot
{
    // generates the root document
    NSXMLElement* root = [[NSXMLElement alloc] initWithName:@"svg"];
    
    [self applyDefaultsForRoot:_svg.rootLayer
                     toElement:root];
    
    [root removeAttributeForName:IJSVGAttributeWidth];
    [root removeAttributeForName:IJSVGAttributeHeight];

    // sort out viewbox
    NSRect viewBox = _svg.viewBox;
    NSMutableDictionary* attributes = [[NSMutableDictionary alloc] initWithDictionary:@{
        IJSVGAttributeViewBox: [self viewBoxWithRect:viewBox],
        @"xmlns": XML_DOC_NS
    }];

    // add on various XML declaritive things
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveXMLDeclaration) == NO) {
        attributes[@"version"] = [NSString stringWithFormat:@"%g", XML_DOC_VERSION];
    }

    // add on width and height unless specified otherwise
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveWidthHeightAttributes) == NO) {
        attributes[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(_size.width, _floatingPointOptions);
        attributes[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(_size.height, _floatingPointOptions);
    }

    // was there a size set?
    CGFloat scale = 1.f;
    NSMutableArray<IJSVGTransform*>* transforms = [[NSMutableArray alloc] initWithCapacity:2];
    if (CGSizeEqualToSize(CGSizeZero, _size) == NO && (_size.width != viewBox.size.width && _size.height != viewBox.size.height)) {

        // copy the attributes
        if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveWidthHeightAttributes) == NO) {
            attributes[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(_size.width, _floatingPointOptions);
            attributes[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(_size.height, _floatingPointOptions);
        }

        // work out the scale
        const CGFloat _proposedScale = MIN(_size.width / viewBox.size.width,
            _size.height / viewBox.size.height);

        // actually do the scale
        if (_proposedScale != 1.f) {
            // compute x and y, don't multiply 0
            const CGFloat x = viewBox.origin.x == 0.f ? 0.f: (viewBox.origin.x * _proposedScale);
            const CGFloat y = viewBox.origin.y == 0.f ? 0.f: (viewBox.origin.y * _proposedScale);

            // reset the viewbox for the exported SVG
            NSRect newViewBox = (NSRect) {
                .origin = NSMakePoint(x, y),
                .size = NSMakeSize(_size.width,
                    _size.height)
            };
            attributes[IJSVGAttributeViewBox] = [self viewBoxWithRect:newViewBox];

            // do we need to scale?
            if (IJSVGExporterHasOption(_options, IJSVGExporterOptionScaleToSizeIfNecessary) == YES) {
                IJSVGTransform* transform = nil;
                transform = [IJSVGTransform transformByScaleX:_proposedScale
                                                            y:_proposedScale];
                [transforms addObject:transform];

                // reset the scale
                scale = _proposedScale;
            }
        }
    }

    // do we need to center the svg within the box?
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCenterWithinViewBox) == YES) {
        CGPoint transformPoint = CGPointMake(_size.width / 2.f - ((viewBox.size.width * scale) / 2.f),
            _size.height / 2.f - ((viewBox.size.height * scale) / 2.f));

        // work out what transform point we need to do, if any
        if (CGPointEqualToPoint(transformPoint, CGPointZero) == NO) {
            IJSVGTransform* transform = nil;
            transform = [IJSVGTransform transformByTranslatingX:transformPoint.x
                                                              y:transformPoint.y];
            [transforms addObject:transform];
        }
    }

    // any transform for the root node?
    if (transforms.count != 0) {
        // concat the transform
        CGAffineTransform afTransform = IJSVGConcatTransforms(transforms);
        NSXMLElement* transformedElement = [[NSXMLElement alloc] initWithName:@"g"];
        NSString* transString = nil;
        transString = [self transformAttributeStringForTransform:afTransform];
        IJSVGApplyAttributesToElement(
            @{ IJSVGAttributeTransform: transString },
            transformedElement);
        *nestedRoot = transformedElement;
        [root addChild:transformedElement];
    }

    // apply the attributes
    IJSVGApplyAttributesToElement(attributes, root);
    if (*nestedRoot == nil) {
        *nestedRoot = root;
    }
    return root;
}

- (void)applyXLinkToRootElement
{
    // simply flag check
    if (_appliedXLink == YES) {
        return;
    }

    // set and add the attribute onto the rootElement
    _appliedXLink = YES;
    NSXMLElement* root = _dom.rootElement;
    NSString* const attributeName = @"xmlns:xlink";
    IJSVGApplyAttributesToElement(@{ attributeName: XML_DOC_NSXLINK }, root);
}

- (NSString*)generateID
{
    const NSArray* chars = IJSVGShortCharacterArray();
    if (_idCount < chars.count) {
        return chars[_idCount++];
    }

    if ((_idCount % chars.count) == 0) {
        _shortIdCount++;
    }
    return [NSString stringWithFormat:@"%@%ld", chars[(_idCount++ % chars.count)], _shortIdCount];
}

- (void)_generateDOMDocument
{
    _idCount = 0;
    _shortIdCount = 0;
    _appliedXLink = NO;
    _dom = nil;
    _defElement = nil;
    
    
    // create the stand alone DOM
    NSXMLElement* nestedRoot = nil;
    NSXMLElement* rootNode = [self rootNode:&nestedRoot];
    _dom = [[NSXMLDocument alloc] initWithRootElement:rootNode];
    _dom.version = XML_DOCTYPE_VERSION;
    _dom.characterEncoding = XML_DOC_CHARSET;

    // sort out stuff, so here we go...
    for(NSXMLElement* childLayer in _svg.rootLayer.sublayers) {
        [self _recursiveParseFromLayer:(IJSVGLayer*)childLayer
                           intoElement:nestedRoot];
    }

    // this needs to be added incase it needs to be cleaned
    NSXMLElement* defNode = [self defElement];
    if (defNode.childCount != 0) {
        [_dom.rootElement insertChild:[self defElement]
                              atIndex:0];
    }

    // cleanup
    [self _cleanup];

    // could had been removed during cleaning process needs to be added back in!
    if (defNode.childCount != 0 && defNode.parent == nil) {
        [_dom.rootElement insertChild:[self defElement]
                              atIndex:0];
    }

    // add generator
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveComments) == NO) {
        NSXMLNode* generatorNode = [[NSXMLNode alloc] initWithKind:NSXMLCommentKind];
        generatorNode.stringValue = XML_DOC_GENERATOR;
        [_dom.rootElement insertChild:generatorNode
                              atIndex:0];
    }
}

- (void)_cleanup
{
    // remove hidden elements
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveHiddenElements) == YES) {
        [self _removeHiddenElements];
    }

    // convert any duplicate paths into use
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCreateUseForPaths) == YES) {
        [self _convertUseElements];
    }

    // cleanup def
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveUselessDef) == YES) {
        [self _cleanDef];
    }

    // collapse groups
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCollapseGroups) == YES) {
        [self _collapseGroups];
    }

    // clean any blank groups
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveUselessGroups) == YES) {
        [self _cleanEmptyGroups];
    }

    // sort attributes
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionSortAttributes) == YES) {
        [self _sortAttributesOnElement:_dom.rootElement];
    }

    // compress groups together
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCollapseGroups) == YES) {
        [self _compressGroups];
    }

    // collapse gradients?
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCollapseGradients) == YES) {
        [self _collapseGradients];
    }

    // create classes?
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCreateClasses) == YES) {
        [self _createClasses];
    }

    // move attributes to group
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionMoveAttributesToGroup) == YES) {
        [self _moveAttributesToGroupWithElement:_dom.rootElement];
    }

    // any use cleaning
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCreateUseForPaths) == YES) {
        [self _cleanupUseTransforms];
    }

    // remove any defaults
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveDefaultValues) == YES) {
        [self _removeDefaultAttributes];
    }
}

- (void)_cleanupUseTransforms
{
    NSArray<NSXMLElement*>* elements = [_dom nodesForXPath:@"//use"
                                                     error:nil];
    for (NSXMLElement* element in elements) {
        NSString* att = [element attributeForName:IJSVGAttributeTransform].stringValue;
        if (att == nil || [element attributeForName:IJSVGAttributeX] != nil ||
            [element attributeForName:IJSVGAttributeY] != nil) {
            continue;
        }

        // at this point we can move the x and y
        NSArray<IJSVGTransform*>* transforms = [IJSVGTransform transformsForString:att];
        if (transforms.count == 1 && transforms.firstObject.command == IJSVGTransformCommandTranslate) {
            IJSVGTransform* transform = transforms.firstObject;
            [element removeAttributeForName:IJSVGAttributeTransform];

            // x
            NSXMLNode* att = [[NSXMLNode alloc] initWithKind:NSXMLAttributeKind];
            att.name = IJSVGAttributeX;
            att.stringValue = IJSVGShortFloatStringWithOptions(transform.parameters[0], _floatingPointOptions);
            [element addAttribute:att];

            // y
            att = [[NSXMLNode alloc] initWithKind:NSXMLAttributeKind];
            att.name = IJSVGAttributeY;
            att.stringValue = IJSVGShortFloatStringWithOptions(transform.parameters[1], _floatingPointOptions);
            [element addAttribute:att];
        }
    }
}

- (void)_createClasses
{
    const NSArray* inhert = IJSVGInheritableAttributes();
    NSArray<NSXMLElement*>* elements = [_dom nodesForXPath:@"//*"
                                                     error:nil];
    NSMutableDictionary* rules = [[NSMutableDictionary alloc] init];
    for (NSXMLElement* element in elements) {
        NSDictionary* inhertEl = [self intersectableAttributes:IJSVGElementAttributeDictionary(element)
                                         inheritableAttributes:inhert];
        NSString* styles = [self styleSheetRulesFromDictionary:inhertEl];
        NSString* className = nil;
        if ((className = [rules objectForKey:styles]) == nil) {
            className = [NSString stringWithFormat:@"%@", [self generateID]];
            rules[styles] = className;
        }

        for (NSString* attributeName in inhertEl) {
            [element removeAttributeForName:attributeName];
        }
        IJSVGApplyAttributesToElement(@{ @"class": className }, element);
    }

    // add styles to dom
    NSXMLElement* styles = [[NSXMLElement alloc] initWithName:@"style"];
    NSXMLNode* node = [[NSXMLNode alloc] initWithKind:NSXMLTextKind];

    NSMutableArray* classes = [[NSMutableArray alloc] initWithCapacity:rules.count];
    for (NSString* r in rules) {
        [classes addObject:[NSString stringWithFormat:@".%@%@", rules[r], r]];
    }
    node.stringValue = [classes componentsJoinedByString:@""];
    [styles addChild:node];
    [_dom.rootElement insertChild:styles atIndex:0];
}

- (NSString*)styleSheetRulesFromDictionary:(NSDictionary*)dict
{
    NSMutableArray* array = [[NSMutableArray alloc] initWithCapacity:dict.count];
    for (NSString* key in dict.allKeys) {
        [array addObject:[NSString stringWithFormat:@"%@: %@;", key, dict[key]]];
    }
    return [NSString stringWithFormat:@"{%@}", [array componentsJoinedByString:@" "]];
}

- (void)_sortAttributesOnElement:(NSXMLElement*)element
{
    // only apply to XML elements, not XMLNodes
    if ([element isKindOfClass:[NSXMLElement class]] == NO) {
        return;
    }
    [self sortAttributesOnElement:element];
    for (NSXMLElement* child in element.children) {
        [self _sortAttributesOnElement:child];
    }
}

- (void)_removeHiddenElements
{
    // find any elements where they have a style, but the element itself
    // must not be in the defs
    NSArray<NSXMLElement*>* elements = [_dom nodesForXPath:@"//*[@display='none']"
                                                     error:nil];

    for (NSXMLElement* element in elements) {
        NSXMLElement* parent = (NSXMLElement*)element.parent;
        [parent removeChildAtIndex:element.index];
    }
}

- (void)_collapseGradients
{
    NSString* xPath = @"//defs/*[self::linearGradient or self::radialGradient]";
    NSArray<NSXMLElement*>* gradients = [_dom nodesForXPath:xPath error:nil];
    for (NSInteger i = 0; i < gradients.count; i++) {
        if (i != 0) {
            NSXMLElement* gradientA = gradients[i];
            NSXMLElement* gradientB = nil;
            for (NSInteger s = (i - 1); s >= 0; s--) {
                gradientB = gradients[s];
                if ([self compareElementChildren:gradientA toElement:gradientB] == YES) {
                    NSString* idString = [gradientB attributeForName:IJSVGAttributeID].stringValue;
                    if (idString == nil || idString.length == 0) {
                        idString = [self identifierForElement:gradientA];
                        IJSVGApplyAttributesToElement(@{ IJSVGAttributeID: idString }, gradientB);
                    }
                    NSDictionary* atts = @{ @"xlink:href": IJSVGHash(idString) };
                    IJSVGApplyAttributesToElement(atts, gradientA);
                    [self applyXLinkToRootElement];
                    [gradientA setChildren:nil];
                    break;
                }
            }
        }
    }
}

- (BOOL)compareElementChildren:(NSXMLElement*)element
                     toElement:(NSXMLElement*)toElement
{
    NSArray* childrenA = element.children;
    NSArray* childrenB = toElement.children;
    if (childrenA.count != childrenB.count) {
        return NO;
    }
    for (NSInteger i = 0; i < childrenA.count; i++) {
        NSXMLElement* childA = childrenA[i];
        NSXMLElement* childB = childrenB[i];
        if ([self compareElement:childA withElement:childB] == NO) {
            return NO;
        }
    }
    return YES;
}

- (void)_moveAttributesToGroupWithElement:(NSXMLElement*)parentElement
{
    const NSArray<NSString*>* excludedElements = @[ @"script", @"style", @"defs" ];
    if ([excludedElements containsObject:parentElement.name]) {
        return;
    }

    const NSArray<NSString*>* inheritableAttributes = IJSVGInheritableAttributes();
    __block NSDictionary<NSString*, NSString*>* intersection = nil;
    NSMutableArray<NSXMLElement*>* currentGroup = [[NSMutableArray alloc] init];

    BOOL (^createGroupIfRequired)(void) = ^BOOL {
        // memory clean
        if (currentGroup.count < 2) {
            [currentGroup removeAllObjects];
            intersection = nil;
            return NO;
        }

        // at this point we can create a new group and remove all the attributes
        NSInteger insertIndex = currentGroup.lastObject.index;
        NSXMLElement* group = [[NSXMLElement alloc] initWithName:@"g"];
        IJSVGApplyAttributesToElement(intersection, group);

        // add back into the dom
        [(NSXMLElement*)currentGroup.lastObject.parent replaceChildAtIndex:insertIndex
                                                                  withNode:group];
        for (NSXMLElement* child in currentGroup) {
            @autoreleasepool {
                NSDictionary<NSString*, NSString*>* childIntersection = nil;
                NSDictionary<NSString*, NSString*>* childAttributes = nil;
                childAttributes = [self intersectableAttributes:IJSVGElementAttributeDictionary(child)
                                          inheritableAttributes:inheritableAttributes];
                childIntersection = [self intersectionInheritableAttributes:childAttributes
                                                          currentAttributes:intersection
                                                      inheritableAttributes:inheritableAttributes];
                for (NSString* attributeName in childIntersection.allKeys) {
                    [child removeAttributeForName:attributeName];
                }
                // move the child to the group
                [child detach];
                [group addChild:child];
            }
        }

        // memory clean
        [currentGroup removeAllObjects];
        intersection = nil;

        return YES;
    };

    for (NSInteger i = 0; i < parentElement.children.count; i++) {
        @autoreleasepool {
            // the current elements attributes that are inheritable
            NSXMLElement* element = (NSXMLElement*)parentElement.children[i];
            NSDictionary<NSString*, NSString*>* attributes = nil;
            attributes = [self intersectableAttributes:IJSVGElementAttributeDictionary(element)
                                 inheritableAttributes:inheritableAttributes];

            if (intersection == nil) {
                intersection = attributes;
                [currentGroup addObject:element];
            }

            NSXMLElement* nextSibling = element;
            while ((nextSibling = (NSXMLElement*)nextSibling.nextSibling) != nil) {
                @autoreleasepool {
                    NSDictionary<NSString*, NSString*>* siblingAttributes = nil;
                    NSDictionary<NSString*, NSString*>* siblingIntersection = nil;
                    siblingAttributes = [self intersectableAttributes:IJSVGElementAttributeDictionary(nextSibling)
                                                inheritableAttributes:inheritableAttributes];
                    siblingIntersection = [self intersectionInheritableAttributes:intersection
                                                                currentAttributes:siblingAttributes
                                                            inheritableAttributes:inheritableAttributes];
                    if (siblingIntersection == nil) {
                        createGroupIfRequired();
                        // make sure we set the index after
                        // as it could had changed whilst being added
                        // to a group
                        i = nextSibling.index - 1;
                        break;
                    }

                    // append to current list
                    [currentGroup addObject:nextSibling];
                }
            }

            // anything left over
            createGroupIfRequired();
        }
    }

    // perform the recursive calls to all children that are groups
    // including ones that were just created
    for (NSXMLElement* element in parentElement.children) {
        if ([element.name isEqualToString:@"g"]) {
            [self _moveAttributesToGroupWithElement:element];
        }
    }
}

- (NSDictionary*)intersectableAttributes:(NSDictionary*)atts
                   inheritableAttributes:(const NSArray*)inheritable
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    for (NSString* key in atts.allKeys) {
        if ([inheritable containsObject:key]) {
            dict[key] = atts[key];
        }
    }
    return dict;
}

- (NSDictionary*)intersectionInheritableAttributes:(NSDictionary*)newAttributes
                                 currentAttributes:(NSDictionary*)currentAttributes
                             inheritableAttributes:(const NSArray*)inheritableAtts
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    for (NSString* key in newAttributes.allKeys) {
        // make sure they are the same and
        // they are inheritable
        if ([currentAttributes objectForKey:key] == nil) {
            return nil;
        }

        if ([currentAttributes objectForKey:key] != nil &&
            [inheritableAtts containsObject:key] &&
            [newAttributes[key] isEqualToString:currentAttributes[key]]) {
            dict[key] = currentAttributes[key];
        }
    }

    // nothing to return, kill it
    if (dict.count == 0) {
        return nil;
    }
    return dict;
}

- (void)_cleanDef
{
    NSXMLElement* defNode = [self defElement];
    if (defNode.children == 0) {
        NSXMLElement* parent = (NSXMLElement*)defNode.parent;
        [parent removeChildAtIndex:defNode.index];
    }
}

- (void)_cleanEmptyGroups
{
    @autoreleasepool {
        // cleanup any groups that are completely useless
        NSArray* groups = [_dom nodesForXPath:@"//g" error:nil];
        for (NSXMLElement* element in groups) {
            NSXMLElement* parent = (NSXMLElement*)element.parent;
            if (element.childCount == 0) {
                // empty group
                [(NSXMLElement*)element.parent removeChildAtIndex:element.index];
            } else if (element.attributes.count == 0) {
                // no useful data on the group
                NSInteger index = element.index;
                for (NSXMLElement* child in element.children) {
                    [(NSXMLElement*)child.parent removeChildAtIndex:child.index];
                    [parent insertChild:child
                                atIndex:index++];
                }
                [parent removeChildAtIndex:element.index];
            }
        }
    }
}

- (void)_compressGroups
{
    NSArray* groups = [_dom nodesForXPath:@"//g" error:nil];
    for (NSXMLElement* group in groups) {

        // whats the next group?
        if (group.parent == nil) {
            continue;
        }

        // compare each group with its next sibling
        NSXMLElement* nextGroup = (NSXMLElement*)group.nextSibling;
        while ([self compareElement:group withElement:nextGroup]) {
            // move each child into the older group
            for (NSXMLElement* child in nextGroup.children) {
                [nextGroup removeChildAtIndex:child.index];
                [group addChild:child];
            }

            // remove the newer
            NSXMLElement* n = nextGroup;
            nextGroup = (NSXMLElement*)nextGroup.nextSibling;
            [(NSXMLElement*)n.parent removeChildAtIndex:n.index];
        }
    }
}

- (void)_collapseGroups
{
    NSArray* groups = [_dom nodesForXPath:@"//g" error:nil];
    const NSArray* inheritable = IJSVGInheritableAttributes();
    for (NSXMLElement* group in groups) {

        // dont do anything due to it being referenced
        if ([group attributeForName:IJSVGAttributeID] != nil) {
            return;
        }

        if (group.attributes.count != 0 && group.children.count == 1) {

            // grab the first child as its a loner
            NSXMLElement* child = (NSXMLElement*)group.children[0];
            if ([child attributeForName:IJSVGAttributeTransform] != nil) {
                continue;
            }

            for (NSXMLNode* gAttribute in group.attributes) {

                // if it just doesnt have the attriute, just add it
                if ([child attributeForName:gAttribute.name] == NO) {
                    // remove first, or throws a wobbly
                    [group removeAttributeForName:gAttribute.name];
                    [child addAttribute:gAttribute];
                } else if ([gAttribute.name isEqualToString:IJSVGAttributeTransform]) {
                    // transform requires concatination
                    NSXMLNode* childTransform = [child attributeForName:IJSVGAttributeTransform];
                    childTransform.stringValue = [NSString stringWithFormat:@"%@ %@",
                                                           gAttribute.stringValue, childTransform.stringValue];

                } else if ([inheritable containsObject:gAttribute.name] == NO) {
                    // if its not inheritable, only remove it if its not equal
                    NSXMLNode* aAtt = [child attributeForName:gAttribute.name];
                    if (aAtt == nil || (aAtt != nil && [aAtt.stringValue isEqualToString:gAttribute.stringValue] == NO)) {
                        continue;
                    }
                }
                [group removeAttributeForName:gAttribute.name];
            }

            // remove the group as its useless!
            if (group.attributes.count == 0) {
                [child detach];
                [(NSXMLElement*)group.parent replaceChildAtIndex:group.index
                                                        withNode:child];
            }
        }
    }
}

- (BOOL)compareElement:(NSXMLElement*)element
           withElement:(NSXMLElement*)anotherElement
{
    // not a matching element
    if ([element.name isEqualToString:anotherElement.name] == NO ||
        element.attributes.count != anotherElement.attributes.count) {
        return NO;
    }

    // compare attributes
    for (NSXMLNode* attribute in element.attributes) {
        NSString* compareString = [anotherElement attributeForName:attribute.name].stringValue;
        if ([attribute.stringValue isEqualToString:compareString] == NO) {
            return NO;
        }
    }
    return YES;
}

- (void)_convertUseElements
{
    @autoreleasepool {
        NSArray* paths = [_dom nodesForXPath:@"//path"
                                       error:nil];

        NSCountedSet* set = [[NSCountedSet alloc] init];
        for (NSXMLElement* element in paths) {
            [set addObject:[element attributeForName:IJSVGAttributeD].stringValue];
        }

        NSMutableDictionary* defs = [[NSMutableDictionary alloc] init];

        // now actually compute them
        for (NSXMLElement* element in paths) {
            NSString* data = [element attributeForName:IJSVGAttributeD].stringValue;
            if ([set countForObject:data] == 1) {
                continue;
            }

            // at this point, we know the path is being used more then once
            NSXMLElement* defParentElement = nil;
            if ((defParentElement = [defs objectForKey:data]) == nil) {
                // create the def
                NSXMLElement* element = [[NSXMLElement alloc] init];
                element.name = @"path";

                NSDictionary* atts = @{
                    IJSVGAttributeD: data,
                    IJSVGAttributeID: [self identifierForElement:element]
                };
                IJSVGApplyAttributesToElement(atts, element);

                // store it against the def
                defs[data] = element;
                defParentElement = element;
            }

            // we know at this point, we need to swap out the path to a use
            NSXMLElement* use = [[NSXMLElement alloc] init];
            use.name = @"use";

            // grab the id
            NSString* pathId = [defParentElement attributeForName:IJSVGAttributeID].stringValue;

            NSXMLNode* useAttribute = [[NSXMLNode alloc] initWithKind:NSXMLAttributeKind];
            useAttribute.name = IJSVGAttributeXLink;
            useAttribute.stringValue = IJSVGHash(pathId);
            [use addAttribute:useAttribute];
            [self applyXLinkToRootElement];

            // remove the d attribute
            for (NSXMLNode* attribute in element.attributes) {
                if ([attribute.name isEqualToString:IJSVGAttributeD]) {
                    continue;
                }
                [element removeAttributeForName:attribute.name];
                [use addAttribute:attribute];
            }

            // swap it out
            [(NSXMLElement*)element.parent replaceChildAtIndex:element.index
                                                      withNode:use];
        }

        // add the defs back in
        NSXMLElement* def = [self defElement];
        for (NSXMLElement* defElement in defs.allValues) {
            [def addChild:defElement];
        }
    }
}

- (NSString*)_computedAttribute:(NSString*)attributeName
                     forElement:(NSXMLElement*)element
{
    NSXMLNode* e = (NSXMLNode*)element;
    if (e == _dom.rootElement || e == _dom.rootDocument) {
        return nil;
    }

    NSXMLElement* el = element;
    while (el != nil) {
        NSXMLNode* attribute = [el attributeForName:attributeName];
        if (attribute != nil) {
            break;
        }
        el = (NSXMLElement*)el.parent;
        if (el == _dom.rootElement || (NSXMLNode*)el == _dom.rootDocument) {
            el = nil;
            break;
        }
    }

    NSXMLNode* attribute = [el attributeForName:attributeName];
    if (attribute) {
        return attribute.stringValue;
    }
    return nil;
}

- (void)_removeDefaultAttributesOnElement:(NSXMLElement*)element
{
    const NSDictionary<NSString*, NSString*>* defaults = IJSVGDefaultAttributes();
    const NSArray<NSString*>* inheritables = IJSVGInheritableAttributes();
    if (element.kind == NSXMLElementKind) {
        NSArray<NSXMLNode*>* attributes = element.attributes;
        if ([element attributeForName:IJSVGAttributeID] == nil) {
            for (NSXMLNode* node in attributes) {
                // no value found in defaults
                NSString* val = nil;
                if ((val = defaults[node.name]) == nil) {
                    continue;
                }
                BOOL isInheritable = [inheritables containsObject:node.name];
                NSString* parentComputed = [self _computedAttribute:node.name
                                                         forElement:(NSXMLElement*)element.parent];
                BOOL isDefault = [val isEqualToString:node.stringValue] && (isInheritable == NO || parentComputed == nil);
                if (isDefault) {
                    [element removeAttributeForName:node.name];
                }
            }
        }
    }
    for (NSXMLElement* childElement in element.children) {
        [self _removeDefaultAttributesOnElement:childElement];
    }
}

- (void)_removeDefaultAttributes
{
    [self _removeDefaultAttributesOnElement:_dom.rootElement];
}

- (NSXMLElement*)elementForLayer:(IJSVGLayer*)layer
                      fromParent:(NSXMLElement*)element
{
    // root layer
    if(layer.class == IJSVGRootLayer.class) {
        return [self elementForRoot:(IJSVGRootLayer*)layer
                         fromParent:element];
    }
    
    // shape layer
    if (layer.class == IJSVGShapeLayer.class) {
        return [self elementForShape:(IJSVGShapeLayer*)layer
                          fromParent:element];
    }
    
    // image layer
    if ([layer isKindOfClass:IJSVGImageLayer.class]) {
        return [self elementForImage:(IJSVGImageLayer*)layer
                          fromParent:element];
    }
    
    // filter layer
    if (layer.class == IJSVGFilterLayer.class) {
        return [self elementForFilter:(IJSVGFilterLayer*)layer
                           fromParent:element];
    }
    
    // group layer, or layer that acts as a group
    if (layer.class == IJSVGGroupLayer.class ||
        layer.class == IJSVGTransformLayer.class ||
        layer.class == IJSVGBasicLayer.class) {
        return [self elementForGroup:layer
                          fromParent:element];
    }
    return nil;
}

- (void)_recursiveParseFromLayer:(IJSVGLayer*)layer
                     intoElement:(NSXMLElement*)element
{
    NSXMLElement* el = [self elementForLayer:layer
                                  fromParent:element];
    if(el != nil) {
        [element addChild:el];
    }
}

- (NSString*)transformAttributeStringForTransform:(CGAffineTransform)transform
{
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRoundTransforms) == YES) {
        return [IJSVGTransform affineTransformToSVGTransformComponentString:transform
                                                       floatingPointOptions:_floatingPointOptions];
    }
    return [IJSVGTransform affineTransformToSVGTransformComponentString:transform];
}

- (void)applyTransformToElement:(NSXMLElement*)element
                      fromLayer:(IJSVGLayer*)layer
{
    CGAffineTransform transform = layer.affineTransform;
    if (CGAffineTransformEqualToTransform(transform, CGAffineTransformIdentity) == YES) {
        return;
    }

    // append the string
    NSString* transformStr = [self transformAttributeStringForTransform:transform];

    // apply it to the node
    IJSVGApplyAttributesToElement(@{ IJSVGAttributeTransform: transformStr }, element);
}

- (NSXMLElement*)elementForGroup:(IJSVGLayer*)layer
                      fromParent:(NSXMLElement*)parent
{
    // create the element
    NSXMLElement* e = [[NSXMLElement alloc] init];
    e.name = @"g";

    // stick defaults
    [self applyDefaultsToElement:e
                       fromLayer:layer];

    // add group children
    for (IJSVGLayer* childLayer in layer.sublayers) {
        [self _recursiveParseFromLayer:childLayer
                           intoElement:e];
    }

    return e;
}

- (void)applyDefaultsForRoot:(IJSVGRootLayer*)layer
                   toElement:(NSXMLElement*)element
{
    CGSize parentSize = layer.superlayer.frame.size;
    NSMutableDictionary<NSString*, NSString*>* attributes = [[NSMutableDictionary alloc] init];
    if(layer.viewBox != nil) {
        CGRect viewBox = [layer.viewBox computeValue:parentSize];
        attributes[IJSVGAttributeViewBox] = [self viewBoxWithRect:viewBox];
    }
    
    NSString* aspectRatio = [self viewBoxAlignment:layer.viewBoxAlignment
                                       meetOrSlice:layer.viewBoxMeetOrSlice];
    if(aspectRatio != nil) {
        attributes[IJSVGAttributePreserveAspectRatio] = aspectRatio;
    }

    IJSVGUnitSize* size = layer.intrinsicSize;
    if(size != nil) {
        CGSize computedSize = [size computeValue:parentSize];
        attributes[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(computedSize.width, _floatingPointOptions);
        attributes[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(computedSize.height, _floatingPointOptions);
    }
    
    IJSVGApplyAttributesToElement(attributes, element);

    // stick defaults
    [self applyDefaultsToElement:element
                       fromLayer:layer];
    
    CGFloat coordValue = 0.f;
    CGRect frame = layer.frame;
    if((coordValue = frame.origin.x) != 0.f) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeX: IJSVGShortFloatStringWithOptions(coordValue, _floatingPointOptions)
        }, element);
    }
    if((coordValue = frame.origin.y) != 0.f) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeY: IJSVGShortFloatStringWithOptions(coordValue, _floatingPointOptions)
        }, element);
    }
}

- (NSXMLElement*)elementForRoot:(IJSVGRootLayer*)layer
                     fromParent:(NSXMLElement*)parent
{
    // create the element
    NSXMLElement* element = [[NSXMLElement alloc] init];
    element.name = @"svg";
    
    [self applyDefaultsForRoot:layer
                     toElement:element];

    // add group children
    for (IJSVGLayer* childLayer in layer.sublayers) {
        [self _recursiveParseFromLayer:childLayer
                           intoElement:element];
    }

    return element;
    
}

- (NSString*)base64EncodedStringFromCGImage:(CGImageRef)image
{
    if (image == nil) {
        return nil;
    }

    // convert the CGImage into an NSImage
    NSBitmapImageRep* rep = [[NSBitmapImageRep alloc] initWithCGImage:image];

    // work out the data
    NSData* data = [rep representationUsingType:NSBitmapImageFileTypePNG
                                     properties:@{}];

    NSString* base64String = [data base64EncodedStringWithOptions:0];
    return [@"data:image/png;base64," stringByAppendingString:base64String];
}

- (void)applyPatternFromLayer:(IJSVGPatternLayer*)layer
                  parentLayer:(IJSVGLayer*)parentLayer
                       stroke:(BOOL)stroke
                    toElement:(NSXMLElement*)element
{
    // now we need the pattern
    IJSVGGroupLayer* patternLayer = (IJSVGGroupLayer*)layer.pattern;

    NSXMLElement* patternElement = [self elementForGroup:patternLayer
                                              fromParent:nil];
    patternElement.name = @"pattern";
    
    // patterns dont allow a transform attribute, however, it is assigned to
    // patternTransform, so if there is a transform attribute, just rename it.
    NSXMLNode* transform = nil;
    if((transform = [patternElement attributeForName:IJSVGAttributeTransform]) != nil) {
        transform.name = IJSVGAttributePatternTransform;
    }
    
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributeID] = [self identifierForElement:patternElement];
    dict[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(layer.patternNode.width.value, _floatingPointOptions);
    dict[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(layer.patternNode.height.value, _floatingPointOptions);
    dict[IJSVGAttributePatternUnits] = layer.patternNode.units == IJSVGUnitObjectBoundingBox ? @"objectBoundingBox": @"userSpaceOnUse";
    dict[IJSVGAttributePatternContentUnits] = layer.patternNode.contentUnits == IJSVGUnitObjectBoundingBox ? @"objectBoundingBox": @"userSpaceOnUse";
    
    if(layer.patternNode.viewBox != nil) {
        dict[IJSVGAttributeViewBox] = [self viewBoxWithRect:[layer.patternNode.viewBox computeValue:CGSizeZero]];
    }

    // sort out x and y position
    IJSVGUnitLength* x = layer.patternNode.x;
    IJSVGUnitLength* y = layer.patternNode.y;

    if (x.value != 0) {
        dict[IJSVGAttributeX] = [layer.patternNode.x stringValue];
    }

    if (y.value != 0) {
        dict[IJSVGAttributeY] = [layer.patternNode.y stringValue];
    }

    IJSVGApplyAttributesToElement(dict, patternElement);

    [[self defElement] addChild:patternElement];

    // now the use statement
    NSXMLElement* useElement = [[NSXMLElement alloc] init];
    useElement.name = @"use";

    // now add the fill
    if (stroke == NO) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeFill: IJSVGHashURL([patternElement attributeForName:IJSVGAttributeID].stringValue)
        }, element);

        // fill opacity
        if (patternLayer.opacity != 1.f) {
            IJSVGApplyAttributesToElement(@{
                IJSVGAttributeFillOpacity: IJSVGShortFloatStringWithOptions(patternLayer.opacity, _floatingPointOptions)
            }, element);
        }
    } else {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeStroke: IJSVGHashURL([patternElement attributeForName:IJSVGAttributeID].stringValue)
        }, element);
    }
}

- (void)applyGradientFromLayer:(IJSVGGradientLayer*)layer
                   parentLayer:(IJSVGLayer*)parentLayer
                        stroke:(BOOL)stroke
                     toElement:(NSXMLElement*)element
{
    IJSVGGradient* gradient = layer.gradient;
    NSXMLElement* gradientElement = [[NSXMLElement alloc] init];

    // work out linear gradient
    if (gradient.class == IJSVGLinearGradient.class) {
        IJSVGLinearGradient* lGradient = (IJSVGLinearGradient*)gradient;
        gradientElement.name = @"linearGradient";
        NSDictionary* dict = @{
            IJSVGAttributeX1: [lGradient.x1 stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeY1: [lGradient.y1 stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeX2: [lGradient.x2 stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeY2: [lGradient.y2 stringValueWithFloatingPointOptions:_floatingPointOptions]
        };

        // give it the attibutes
        IJSVGApplyAttributesToElement(dict, gradientElement);
    } else {
        // assume radial
        IJSVGRadialGradient* rGradient = (IJSVGRadialGradient*)gradient;
        gradientElement.name = @"radialGradient";
        NSDictionary* dict = @{
            IJSVGAttributeCX: [rGradient.cx stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeCY: [rGradient.cy stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeFX: [rGradient.fx stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeFY: [rGradient.fy stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeR: [rGradient.r stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeFR: [rGradient.fr stringValueWithFloatingPointOptions:_floatingPointOptions]
        };

        // give it the attributes
        IJSVGApplyAttributesToElement(dict, gradientElement);
    }
    
    // apply the identifier
    NSString* gradKey = [self identifierForElement:gradientElement];
    IJSVGApplyAttributesToElement(@{IJSVGAttributeID: gradKey}, gradientElement);

    // apply the units
    if (layer.gradient.units == IJSVGUnitUserSpaceOnUse) {
        IJSVGApplyAttributesToElement(@{ IJSVGAttributeGradientUnits: @"userSpaceOnUse" },
            gradientElement);
    }

    // add the stops
//    IJSVGColorList* sheet = layer.gradient.computedColorList;
    NSInteger index = 0;
    for (NSColor* color in gradient.colors) {
        // grab each color from the gradient
        NSColor* aColor = color;
        CGFloat location = gradient.locations[index++];

//        if (sheet != nil) {
//            aColor = [sheet proposedColorForColor:aColor];
//        }

        // create the stop element
        NSXMLElement* stop = [[NSXMLElement alloc] init];
        stop.name = @"stop";

        NSMutableDictionary* atts = [[NSMutableDictionary alloc] init];
        atts[IJSVGAttributeOffset] = [NSString stringWithFormat:@"%g%%", (location * 100)];

        // add the color
        IJSVGColorStringOptions options = IJSVGColorStringOptionForceHEX | IJSVGColorStringOptionAllowShortHand;
        NSString* stopColor = [self colorStringForColor:aColor
                                                   flag:IJSVGColorTypeFlagStop
                                                options:options];
        // dont bother adding default
        if ([stopColor isEqualToString:@"#000"] == NO) {
            atts[IJSVGAttributeStopColor] = stopColor;
        }

        // we need to work out the color at this point, annoyingly...
        CGFloat opacity = aColor.alphaComponent;

        // is opacity is equal to 1, no need to add it as spec
        // defaults opacity to 1 anyway :)
        if (opacity != 1.f) {
            atts[IJSVGAttributeStopOpacity] = IJSVGShortFloatStringWithOptions(opacity, _floatingPointOptions);
        }

        // att the attributes
        IJSVGApplyAttributesToElement(atts, stop);

        // append the stop the gradient
        [gradientElement addChild:stop];
    }

    // append it to the defs
    [[self defElement] addChild:gradientElement];

    // work out the transform
    NSArray* transforms = layer.gradient.transforms;
    if (transforms.count != 0.f) {
        CGAffineTransform transform = IJSVGConcatTransforms(transforms);
        NSString* transformString = [self transformAttributeStringForTransform:transform];
        IJSVGApplyAttributesToElement(@{ IJSVGAttributeGradientTransform: transformString }, gradientElement);
    }

    // add it to the element passed in
    if (stroke == NO) {
        IJSVGApplyAttributesToElement(@{ IJSVGAttributeFill: IJSVGHashURL(gradKey) }, element);

        // fill opacity
        if (layer.opacity != 1.f) {
            IJSVGApplyAttributesToElement(@{ IJSVGAttributeFillOpacity: IJSVGShortFloatStringWithOptions(layer.opacity, _floatingPointOptions) }, element);
        }
    } else {
        IJSVGApplyAttributesToElement(@{ IJSVGAttributeStroke: IJSVGHashURL(gradKey) }, element);
    }
}

- (NSXMLElement*)elementForFilter:(IJSVGFilterLayer*)layer
                       fromParent:(NSXMLElement*)parent
{
    [self _recursiveParseFromLayer:(IJSVGLayer*)layer.sublayer
                       intoElement:parent];
    return nil;
}

- (NSXMLElement*)elementForImage:(IJSVGImageLayer*)layer
                      fromParent:(NSXMLElement*)parent
{
    NSString* base64String = [self base64EncodedStringFromCGImage:(CGImageRef)layer.contents];
    if (base64String == nil || layer.contents == nil) {
        return nil;
    }

    // image element for the SVG
    NSXMLElement* imageElement = [[NSXMLElement alloc] init];
    imageElement.name = @"image";

    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributeID] = [self identifierForElement:imageElement];
    dict[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(layer.frame.size.width, _floatingPointOptions);
    dict[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(layer.frame.size.height, _floatingPointOptions);
    dict[IJSVGAttributeXLink] = base64String;
    [self applyXLinkToRootElement];

    // work out any position
    if (layer.frame.origin.x != 0.f) {
        dict[IJSVGAttributeX] = IJSVGShortFloatStringWithOptions(layer.frame.origin.x, _floatingPointOptions);
    }
    if (layer.frame.origin.y != 0.f) {
        dict[IJSVGAttributeY] = IJSVGShortFloatStringWithOptions(layer.frame.origin.y, _floatingPointOptions);
    }

    // add the attributes
    IJSVGApplyAttributesToElement(dict, imageElement);
    return imageElement;
}

- (IJSVGColorStringOptions)colorOptions
{
    IJSVGColorStringOptions options = IJSVGColorStringOptionDefault;
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionColorAllowRRGGBBAA) == YES) {
        options |= IJSVGColorStringOptionAllowRRGGBBAA;
    }
    return options;
}

- (NSString*)elementNameForPrimitiveType:(IJSVGPrimitivePathType)primitiveType
{
    switch (primitiveType) {
    case kIJSVGPrimitivePathTypeRect:
        return @"rect";
    case kIJSVGPrimitivePathTypePolyLine:
        return @"polyline";
    case kIJSVGPrimitivePathTypeEllipse:
        return @"ellipse";
    case kIJSVGPrimitivePathTypeCircle:
        return @"circle";
    case kIJSVGPrimitivePathTypeLine:
        return @"line";
    case kIJSVGPrimitivePathTypePolygon:
        return @"polygon";
    case kIJSVGPrimitivePathTypePath:
    default:
        return @"path";
    }
}

- (NSXMLElement*)elementForShape:(IJSVGShapeLayer*)layer
                      fromParent:(NSXMLElement*)parent
{
    NSXMLElement* e = [[NSXMLElement alloc] init];
    e.name = [self elementNameForPrimitiveType:layer.primitiveType];
    CGPathRef path = layer.path;

    // copy the path as we want to translate
    CGAffineTransform trans = CGAffineTransformMakeTranslation(layer.frame.origin.x,
        layer.frame.origin.y);
    
    // if its stroked, we need to move it back to where it should be, which is just
    // half of the line width, so move it back!
    if([layer matchesTraits:IJSVGLayerTraitStroked] == YES) {
        IJSVGShapeLayer* strokeLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStroke];
        const CGFloat lineWidth = strokeLayer.lineWidth / 2.f;
        CGAffineTransform strokeTransform = CGAffineTransformIdentity;
        strokeTransform = CGAffineTransformMakeTranslation(lineWidth, lineWidth);
        trans = CGAffineTransformConcat(trans, strokeTransform);
    }
    
    CGPathRef transformPath = CGPathCreateCopyByTransformingPath(path, &trans);

    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    BOOL cleanupPaths = IJSVGExporterHasOption(_options, IJSVGExporterOptionCleanupPaths);
    BOOL convertArcs = IJSVGExporterHasOption(_options, IJSVGExporterOptionConvertArcs);
    BOOL convertShapesToPaths = IJSVGExporterHasOption(_options, IJSVGExporterOptionConvertShapesToPaths);
    
    // path
    switch (layer.primitiveType) {
    case kIJSVGPrimitivePathTypeRect: {
        __block BOOL radiusSet = NO;
        IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
            if (radiusSet == NO && pathElement->type == kCGPathElementAddCurveToPoint) {
                radiusSet = YES;
                CGFloat radX = fabs(pathElement->points[2].x - currentPoint.x);
                CGFloat radY = fabs(pathElement->points[2].y - currentPoint.y);

                dict[IJSVGAttributeRX] = IJSVGShortFloatStringWithOptions(radX, self->_floatingPointOptions);
                if (radX != radY) {
                    dict[IJSVGAttributeRY] = IJSVGShortFloatStringWithOptions(radY, self->_floatingPointOptions);
                }
            }
        });

        CGRect boundingBox = CGPathGetBoundingBox(transformPath);
        if (cleanupPaths == YES && radiusSet == NO && convertShapesToPaths == YES) {
            // construct array of instructions to do
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray* instructions = [[NSMutableArray alloc] initWithCapacity:5];

            // M -> H -> V -> H -> z
            // M
            IJSVGExporterPathInstruction* instruction = nil;
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                          dataCount:2];
            instruction.data[0] = boundingBox.origin.x;
            instruction.data[1] = boundingBox.origin.y;
            [instructions addObject:instruction];

            // H
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'H'
                                                                          dataCount:1];
            instruction.data[0] = boundingBox.origin.x + boundingBox.size.width;
            [instructions addObject:instruction];

            // V
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'V'
                                                                          dataCount:1];
            instruction.data[0] = boundingBox.origin.y + boundingBox.size.height;
            [instructions addObject:instruction];

            // H
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'H'
                                                                          dataCount:1];
            instruction.data[0] = boundingBox.origin.x;
            [instructions addObject:instruction];

            // Z
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                          dataCount:0];
            [instructions addObject:instruction];
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            if (boundingBox.origin.x != 0.f) {
                dict[IJSVGAttributeX] = IJSVGShortFloatStringWithOptions(boundingBox.origin.x, _floatingPointOptions);
            }
            if (boundingBox.origin.y != 0.f) {
                dict[IJSVGAttributeY] = IJSVGShortFloatStringWithOptions(boundingBox.origin.y, _floatingPointOptions);
            }
            dict[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(boundingBox.size.width, _floatingPointOptions);
            dict[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(boundingBox.size.height, _floatingPointOptions);
        }
        break;
    }
    case kIJSVGPrimitivePathTypeLine: {
        if (cleanupPaths == YES && convertShapesToPaths == YES) {
            // M -> L
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] initWithCapacity:2];
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                switch (pathElement->type) {
                case kCGPathElementMoveToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'L'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                default:
                    break;
                }
            });
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                switch (pathElement->type) {
                case kCGPathElementMoveToPoint: {
                    dict[IJSVGAttributeX1] = IJSVGShortFloatStringWithOptions(pathElement->points[0].x, self->_floatingPointOptions);
                    dict[IJSVGAttributeY1] = IJSVGShortFloatStringWithOptions(pathElement->points[0].y, self->_floatingPointOptions);
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    dict[IJSVGAttributeX2] = IJSVGShortFloatStringWithOptions(pathElement->points[0].x, self->_floatingPointOptions);
                    dict[IJSVGAttributeY2] = IJSVGShortFloatStringWithOptions(pathElement->points[0].y, self->_floatingPointOptions);
                    break;
                }
                default:
                    break;
                }
            });
        }
        break;
    }
    case kIJSVGPrimitivePathTypePolygon:
    case kIJSVGPrimitivePathTypePolyLine: {
        if (cleanupPaths == YES && convertShapesToPaths == YES) {
            // M -> L+
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] init];
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                switch (pathElement->type) {
                case kCGPathElementMoveToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'L'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                default:
                    break;
                }
            });
            if (layer.primitiveType == kIJSVGPrimitivePathTypePolygon) {
                // remove last one if it was M
                if(instructions.lastObject.instruction == 'M') {
                    [instructions removeLastObject];
                }
                IJSVGExporterPathInstruction* instruction = nil;
                instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                              dataCount:0];
                [instructions addObject:instruction];
            }
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            NSMutableArray<NSString*>* points = [[NSMutableArray alloc] init];
            __block CGPathElementType type;
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                type = pathElement->type;
                switch (type) {
                case kCGPathElementMoveToPoint: {
                    pathElement->points[0].x = pathElement->points[0].x;
                    pathElement->points[0].y = pathElement->points[0].y;
                    [points addObject:IJSVGPointToCommandString(pathElement->points[0])];
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    pathElement->points[0].x = pathElement->points[0].x;
                    pathElement->points[0].y = pathElement->points[0].y;
                    [points addObject:IJSVGPointToCommandString(pathElement->points[0])];
                    break;
                }
                default:
                    break;
                }
            });
            // polygon does not need the move to command
            if (layer.primitiveType == kIJSVGPrimitivePathTypePolygon &&
                type == kCGPathElementMoveToPoint) {
                [points removeLastObject];
            }
            dict[IJSVGAttributePoints] = [points componentsJoinedByString:@" "];
        }
        break;
    }
    case kIJSVGPrimitivePathTypeEllipse: {
        CGRect boundingBox = CGPathGetPathBoundingBox(transformPath);
        CGFloat cx = boundingBox.origin.x + boundingBox.size.width / 2.f;
        CGFloat cy = boundingBox.origin.y + boundingBox.size.height / 2.f;
        CGFloat rx = boundingBox.size.width / 2.f;
        CGFloat ry = boundingBox.size.height / 2.f;

        if (cleanupPaths == YES && convertArcs == YES && convertShapesToPaths == YES) {
            // M + A + A +Z
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] initWithCapacity:4];

            // M
            IJSVGExporterPathInstruction* instruction = nil;
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                          dataCount:2];
            instruction.data[0] = cx;
            instruction.data[1] = cy - ry;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = rx;
            instruction.data[1] = ry;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy + ry;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = rx;
            instruction.data[1] = ry;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy - ry;
            [instructions addObject:instruction];

            // Z
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                          dataCount:0];
            [instructions addObject:instruction];
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            dict[IJSVGAttributeCX] = IJSVGShortFloatStringWithOptions(cx, _floatingPointOptions);
            dict[IJSVGAttributeCY] = IJSVGShortFloatStringWithOptions(cy, _floatingPointOptions);
            dict[IJSVGAttributeRX] = IJSVGShortFloatStringWithOptions(rx, _floatingPointOptions);
            dict[IJSVGAttributeRY] = IJSVGShortFloatStringWithOptions(ry, _floatingPointOptions);
        }
        break;
    }
    case kIJSVGPrimitivePathTypeCircle: {
        CGRect boundingBox = CGPathGetPathBoundingBox(transformPath);
        CGFloat cx = boundingBox.origin.x + boundingBox.size.width / 2.f;
        CGFloat cy = boundingBox.origin.y + boundingBox.size.height / 2.f;
        CGFloat r = boundingBox.size.width / 2.f;
        if (cleanupPaths == YES && convertArcs == YES && convertShapesToPaths == YES) {
            // M + A + A +Z
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] initWithCapacity:4];

            // M
            IJSVGExporterPathInstruction* instruction = nil;
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                          dataCount:2];
            instruction.data[0] = cx;
            instruction.data[1] = cy - r;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = r;
            instruction.data[1] = r;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy + r;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = r;
            instruction.data[1] = r;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy - r;
            [instructions addObject:instruction];

            // Z
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                          dataCount:0];
            [instructions addObject:instruction];
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            dict[IJSVGAttributeCX] = IJSVGShortFloatStringWithOptions(cx, _floatingPointOptions);
            dict[IJSVGAttributeCY] = IJSVGShortFloatStringWithOptions(cy, _floatingPointOptions);
            dict[IJSVGAttributeR] = IJSVGShortFloatStringWithOptions(r, _floatingPointOptions);
        }
        break;
    }
    case kIJSVGPrimitivePathTypePath:
    default:
        dict[IJSVGAttributeD] = [self pathFromCGPath:transformPath];
    }

    // memory clean
    CGPathRelease(transformPath);

    // work out even odd rule
    if ([layer.fillRule isEqualToString:kCAFillRuleNonZero] == NO) {
        dict[IJSVGAttributeFillRule] = @"evenodd";
    }

    // fill color
    IJSVGShapeLayer* fillLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeFillGeneric];
    if (fillLayer != nil) {
        NSString* colorString = @"none";
        if(fillLayer.fillColor != NULL) {
            NSColor* fillColor = nil;
            fillColor = [NSColor colorWithCGColor:fillLayer.fillColor];
            colorString = [self colorStringForColor:fillColor
                                               flag:IJSVGColorTypeFlagFill
                                            options:[self colorOptions]];
        }
        dict[IJSVGAttributeFill] = colorString;
        
        // any fill opacity?
        if (fillLayer.opacity != 1.f) {
            dict[IJSVGAttributeFillOpacity] = IJSVGShortFloatStringWithOptions(fillLayer.opacity, _floatingPointOptions);
        }
    }

    // is there a gradient fill?
    IJSVGGradientLayer* gradientLayer = (IJSVGGradientLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeFillGradient];
    if (gradientLayer != nil) {
        [self applyGradientFromLayer:gradientLayer
                         parentLayer:(IJSVGLayer*)layer
                              stroke:NO
                           toElement:e];
    }

    // is there a pattern?
    IJSVGPatternLayer* patternLayer = (IJSVGPatternLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeFillPattern];
    if (patternLayer != nil) {
        [self applyPatternFromLayer:patternLayer
                        parentLayer:(IJSVGLayer*)layer
                             stroke:NO
                          toElement:e];
    }

    // is there a stroke layer?
    if ([layer matchesTraits:IJSVGLayerTraitStroked] == YES) {
        IJSVGShapeLayer* strokeLayer = nil;
        // stroke gradient
        if ((strokeLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStrokeGradient]) != nil) {
            [self applyGradientFromLayer:(IJSVGGradientLayer*)strokeLayer
                             parentLayer:(IJSVGLayer*)layer
                                  stroke:YES
                               toElement:e];

        } else if ((strokeLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStrokePattern]) != nil) {
            // stroke pattern
            [self applyPatternFromLayer:(IJSVGPatternLayer*)strokeLayer
                            parentLayer:(IJSVGLayer*)layer
                                 stroke:YES
                              toElement:e];

        } else if ((strokeLayer = (IJSVGStrokeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStrokeGeneric]) != nil) {
            NSColor* strokeColor = [NSColor colorWithCGColor:strokeLayer.strokeColor];
            NSString* strokeColorString = [self colorStringForColor:strokeColor
                                                               flag:IJSVGColorTypeFlagStroke
                                                            options:[self colorOptions]];

            // could be none
            if (strokeColorString != nil) {
                dict[IJSVGAttributeStroke] = strokeColorString;
                if ([strokeColorString isEqualToString:@"none"] == YES) {
                    // remove the stroke width as its completely useless
                    [dict removeObjectForKey:IJSVGAttributeStrokeWidth];
                }
            }

            // is there a stroke opacity? make sure we add that back on if
            // its not opaque
            if (strokeLayer.opacity != 1.f) {
                dict[IJSVGAttributeStrokeOpacity] = IJSVGShortFloatStringWithOptions(strokeLayer.opacity,
                    _floatingPointOptions);
            }
        }
        
        // swap this over to the actual lowest level stroke layer
        strokeLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStroke];
        
        // stroke
        if (strokeLayer.lineWidth != 0.f) {
            dict[IJSVGAttributeStrokeWidth] = IJSVGShortFloatStringWithOptions(strokeLayer.lineWidth,
                _floatingPointOptions);
        }

        // work out line cap
        if ([strokeLayer.lineCap isEqualToString:kCALineCapButt] == NO) {
            NSString* capStyle = nil;
            if ([strokeLayer.lineCap isEqualToString:kCALineCapRound]) {
                capStyle = @"round";
            } else if ([strokeLayer.lineCap isEqualToString:kCALineCapSquare]) {
                capStyle = @"square";
            }
            if (capStyle != nil) {
                dict[IJSVGAttributeStrokeLineCap] = capStyle;
            }
        }

        // work out line join
        if ([strokeLayer.lineJoin isEqualToString:kCALineJoinMiter] == NO) {
            NSString* joinStyle = nil;
            if ([strokeLayer.lineJoin isEqualToString:kCALineJoinBevel]) {
                joinStyle = @"bevel";
            } else if ([strokeLayer.lineJoin isEqualToString:kCALineJoinRound]) {
                joinStyle = @"round";
            }
            if (joinStyle != nil) {
                dict[IJSVGAttributeStrokeLineJoin] = joinStyle;
            }
        }

        // work out dash offset...
        if (strokeLayer.lineDashPhase != 0.f) {
            dict[IJSVGAttributeStrokeDashOffset] = IJSVGShortFloatStringWithOptions(strokeLayer.lineDashPhase,
                _floatingPointOptions);
        }

        // work out dash array
        if (strokeLayer.lineDashPattern.count != 0) {
            dict[IJSVGAttributeStrokeDashArray] = [strokeLayer.lineDashPattern componentsJoinedByString:@" "];
        }
    }

    // apply the attributes
    IJSVGApplyAttributesToElement(dict, e);

    // apple defaults
    [self applyDefaultsToElement:e
                       fromLayer:(IJSVGLayer*)layer];
    return e;
}

- (void)applyDefaultsToElement:(NSXMLElement*)element
                     fromLayer:(IJSVGLayer*)layer
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];

    // opacity
    if (layer.opacity != 1.f) {
        dict[IJSVGAttributeOpacity] = IJSVGShortFloatStringWithOptions(layer.opacity,
            _floatingPointOptions);
    }

    // blendmode - we only every apply a stylesheet blend mode
    NSMutableDictionary* style = [[NSMutableDictionary alloc] init];
    if (layer.blendingMode != kCGBlendModeNormal) {
        NSString* str = [IJSVGUtils mixBlendingModeForBlendMode:(IJSVGBlendMode)layer.blendingMode];
        if (str != nil) {
            style[IJSVGAttributeBlendMode] = str;
        }
    }

    // hidden?
    if (layer.isHidden) {
        style[IJSVGAttributeDisplay] = @"none";
    }

    if (style.count != 0) {
        NSMutableString* styleString = [[NSMutableString alloc] init];
        for (NSString* styleKey in style.allKeys) {
            NSString* format = [NSString stringWithFormat:@"%@:%@;", styleKey, style[styleKey]];
            [styleString appendString:format];
        }
        dict[IJSVGAttributeStyle] = styleString;
    }

    // add atttributes
    IJSVGApplyAttributesToElement(dict, element);

    // apply transforms
    [self applyTransformToElement:element
                        fromLayer:layer];

    // add any masks...
    if (layer.maskLayer != nil) {
        [self applyMaskToElement:element
                       fromLayer:layer];
    }
    
    // add any clips
    if(layer.clipPath != nil) {
        [self applyClipToElement:element
                       fromLayer:layer];
    }
}

- (void)applyClipToElement:(NSXMLElement*)element
                 fromLayer:(IJSVGLayer*)layer
{
    
}

- (void)applyMaskToElement:(NSXMLElement*)element
                 fromLayer:(IJSVGLayer*)layer
{
    // create the element
    NSXMLElement* mask = [[NSXMLElement alloc] init];
    mask.name = @"mask";

    // create the key
    NSString* maskKey = [self identifierForElement:mask];
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributeID] = maskKey;

    IJSVGLayer* maskLayer = (IJSVGLayer*)layer.maskLayer;
    CGRect maskFrame = maskLayer.frame;
    if (maskFrame.origin.x != 0.f) {
        dict[IJSVGAttributeX] = IJSVGShortFloatStringWithOptions(maskFrame.origin.x,
            _floatingPointOptions);
    }
    if (maskFrame.origin.y != 0.f) {
        dict[IJSVGAttributeY] = IJSVGShortFloatStringWithOptions(maskFrame.origin.y,
            _floatingPointOptions);
    }

    IJSVGApplyAttributesToElement(dict, mask);

    // add the cool stuff
    [self _recursiveParseFromLayer:(IJSVGLayer*)maskLayer
                       intoElement:mask];

    // add mask id to element
    IJSVGApplyAttributesToElement(@{
        IJSVGAttributeMask: IJSVGHashURL(maskKey)
    }, element);

    // add it defs
    [[self defElement] addChild:mask];
}

- (NSXMLDocument*)_dom
{
    if(_dom == nil) {
        @autoreleasepool {
            [self _generateDOMDocument];
        }
    }
    return _dom;
}

- (NSString*)SVGString
{
    NSXMLNodeOptions options = NSXMLNodePrettyPrint;
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCompressOutput) == YES) {
        options = NSXMLNodeOptionsNone;
    }
    options |= NSXMLNodeCompactEmptyElement;
    NSString* output = [[self _dom] XMLStringWithOptions:options];
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveXMLDeclaration) == YES) {
        return [output substringFromIndex:38];
    }
    return output;
}

- (NSData*)SVGData
{
    return [[self SVGString] dataUsingEncoding:NSUTF8StringEncoding];
}

- (IJSVG*)SVG:(NSError**)error
{
    return [[IJSVG alloc] initWithSVGString:self.SVGString
                                      error:error];
}

#pragma mark CGPath stuff

- (NSString*)pathFromCGPath:(CGPathRef)path
{
    // string to store the path in
    NSArray* instructions = [IJSVGExporterPathInstruction instructionsFromPath:path
                                                          floatingPointOptions:_floatingPointOptions];
    return [self pathFromInstructions:instructions];
}

- (NSString*)pathFromInstructions:(NSArray<IJSVGExporterPathInstruction*>*)instructions
{
    // work out what to do...
    if (IJSVGExporterHasOption(_options, IJSVGExporterOptionCleanupPaths) == YES) {
        [IJSVGExporterPathInstruction convertInstructionsToRelativeCoordinates:instructions
                                                          floatingPointOptions:_floatingPointOptions];
        [IJSVGExporterPathInstruction convertInstructionsDataToRounded:instructions
                                                  floatingPointOptions:_floatingPointOptions];
        [IJSVGExporterPathInstruction convertInstructionsToRelativeCoordinates:instructions
                                                          floatingPointOptions:_floatingPointOptions];
        [IJSVGExporterPathInstruction convertInstructionsToMixedAbsoluteRelative:instructions
                                                            floatingPointOptions:_floatingPointOptions];
        instructions = [IJSVGExporterPathInstruction convertInstructionsCurves:instructions
                                                          floatingPointOptions:_floatingPointOptions];
    }
    return [IJSVGExporterPathInstruction pathStringFromInstructions:instructions
                                               floatingPointOptions:_floatingPointOptions];
}

void IJSVGExporterPathCaller(void* info, const CGPathElement* pathElement)
{
    IJSVGCGPathHandler handler = (__bridge IJSVGCGPathHandler)info;
    handler(pathElement);
};

void IJSVGEnumerateCGPathElements(CGPathRef path, IJSVGPathElementEnumerationBlock enumBlock)
{
    __block CGPoint currentPoint = CGPointZero;
    IJSVGCGPathHandler callback = ^(const CGPathElement* _Nonnull element) {
        switch (element->type) {
        case kCGPathElementMoveToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[0];
            break;
        }
        case kCGPathElementAddLineToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[0];
            break;
        }
        case kCGPathElementAddCurveToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[2];
            break;
        }
        case kCGPathElementAddQuadCurveToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[1];
            break;
        }
        case kCGPathElementCloseSubpath: {
            enumBlock(element, currentPoint);
            break;
        }
        }
    };
    if (@available(macOS 10.13, *)) {
        CGPathApplyWithBlock(path, callback);
    } else {
        CGPathApply(path, (__bridge void*)callback, IJSVGExporterPathCaller);
    }
};

- (void)sortAttributesOnElement:(NSXMLElement*)element
{
    const NSArray* order = @[ IJSVGAttributeID, IJSVGAttributeWidth,
                              IJSVGAttributeHeight, IJSVGAttributeX,
                              IJSVGAttributeX1, IJSVGAttributeX2, IJSVGAttributeY,
                              IJSVGAttributeY1, IJSVGAttributeY2,
                              IJSVGAttributeCX, IJSVGAttributeCY, IJSVGAttributeR,
                              IJSVGAttributeFill, IJSVGAttributeStroke, IJSVGAttributeMarker,
                              IJSVGAttributeD, IJSVGAttributePoints, IJSVGAttributeTransform,
                              IJSVGAttributeGradientTransform, IJSVGAttributeXLink ];

    // grab the attributes
    NSArray<NSXMLNode*>* attributes = element.attributes;
    NSInteger count = attributes.count;

    // sort the attributes using a custom sort
    NSArray* sorted = [attributes sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) {
        // tell compiler we are nodes
        NSXMLNode* attribute1 = (NSXMLNode*)obj1;
        NSXMLNode* attribute2 = (NSXMLNode*)obj2;

        // base index
        float aIndex = count;
        float bIndex = count;

        // loop around each order string
        for (NSInteger i = 0; i < order.count; i++) {
            if ([attribute1.name isEqualToString:order[i]]) {
                aIndex = i;
            } else if ([attribute1.name rangeOfString:[order[i] stringByAppendingString:@"-"]].location == 0) {
                aIndex = i + .5;
            }
            if ([attribute2.name isEqualToString:order[i]]) {
                bIndex = i;
            } else if ([attribute2.name rangeOfString:[order[i] stringByAppendingString:@"-"]].location == 0) {
                bIndex = i + .5;
            }
        }

        // return the comparison set
        if (aIndex != bIndex) {
            if (aIndex > bIndex) {
                return NSOrderedDescending;
            } else {
                return NSOrderedAscending;
            }
        }
        return [attribute1.name compare:attribute2.name];
    }];

    // remove all attributes
    for (NSXMLNode* node in attributes) {
        [element removeAttributeForName:node.name];
    }

    // add them back on in order
    for (NSXMLNode* attribute in sorted) {
        [element addAttribute:attribute];
    }
}

#pragma mark Delegate calling methods

- (NSString*)identifierForElement:(NSXMLElement* _Nullable)element
{
    NSString* identifier = nil;
    if(_respondsTo.identifierForElement == 1) {
        __weak id weakSelf = self;
        NSString* (^block)(void) = ^NSString*(void) {
            return [weakSelf generateID];
        };
        IJSVGNodeType type = [IJSVGNode typeForString:element.localName
                                                 kind:element.kind];
        identifier = [_delegate svgExporter:self
                       identifierForElement:element
                                       type:type
                                  defaultID:block];
        if(identifier != nil) {
            return identifier;
        }
    }
    return [self generateID];
}

- (NSString*)colorStringForColor:(NSColor*)color
                            flag:(IJSVGColorTypeFlags)flag
                         options:(IJSVGColorStringOptions)options
{
    NSString* colorString = nil;
    if(_respondsTo.stringForColor == 1) {
        color = [IJSVGColor computeColorSpace:color];
        colorString = [_delegate svgExporter:self
                              stringForColor:color
                                       flags:flag
                                     options:options];
        if(colorString != nil) {
            return colorString;
        }
    }
    return [IJSVGColor colorStringFromColor:color
                                    options:options];
}

@end
